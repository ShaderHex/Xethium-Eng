// main.cpp

#include "raylib.h"

#include "rlImGui.h"

#include "rlgl.h"

#include "raymath.h"


#include "imgui.h"

#include "ImGuizmo.h"


// --- Helpers ---

static void MatrixToFloat16(const Matrix& mat, float out[16]) {

    out[0]  = mat.m0;  out[1]  = mat.m1;  out[2]  = mat.m2;  out[3]  = mat.m3;

    out[4]  = mat.m4;  out[5]  = mat.m5;  out[6]  = mat.m6;  out[7]  = mat.m7;

    out[8]  = mat.m8;  out[9]  = mat.m9;  out[10] = mat.m10; out[11] = mat.m11;

    out[12] = mat.m12; out[13] = mat.m13; out[14] = mat.m14; out[15] = mat.m15;

}

static Matrix Float16ToMatrix(const float in[16]) {

    Matrix m;

    m.m0=in[0]; m.m1=in[1]; m.m2=in[2]; m.m3=in[3];

    m.m4=in[4]; m.m5=in[5]; m.m6=in[6]; m.m7=in[7];

    m.m8=in[8]; m.m9=in[9]; m.m10=in[10]; m.m11=in[11];

    m.m12=in[12]; m.m13=in[13]; m.m14=in[14]; m.m15=in[15];

    return m;

}

static const float* MatrixToFloatPtr(const Matrix& mat) {

    return reinterpret_cast<const float*>(&mat);

}


int main() {

    InitWindow(1280, 720, "raylib + ImGuizmo clean drag");

    SetTargetFPS(60);


    rlImGuiSetup(true);


    Camera3D camera = {0};

    camera.position   = { 6.0f, 6.0f, 6.0f };

    camera.target     = { 0.0f, 0.0f, 0.0f };

    camera.up         = { 0.0f, 1.0f, 0.0f };

    camera.fovy       = 45.0f;

    camera.projection = CAMERA_PERSPECTIVE;


    // Object transform

    Matrix modelMat = MatrixIdentity();


    // UI state

    ImGuizmo::OPERATION op = ImGuizmo::TRANSLATE;

    ImGuizmo::MODE mode = ImGuizmo::LOCAL; // switchable to WORLD

    bool snapEnabled = false;

    float snapVal[3] = {0.5f, 5.0f, 0.1f}; // move, rotate(deg), scale

    ImGuizmo::AllowAxisFlip(false); // keep axis directions stable


    while (!WindowShouldClose()) {

        // ----- Start the frame -----

        BeginDrawing();

        ClearBackground(RAYWHITE);


        // Begin ImGui early so we can read io and gizmo hover/using to gate camera input

        rlImGuiBegin();


        // Controls window

        ImGui::Begin("Gizmo Controls");

        if (ImGui::RadioButton("Translate", op == ImGuizmo::TRANSLATE)) op = ImGuizmo::TRANSLATE;

        ImGui::SameLine();

        if (ImGui::RadioButton("Rotate",    op == ImGuizmo::ROTATE))    op = ImGuizmo::ROTATE;

        ImGui::SameLine();

        if (ImGui::RadioButton("Scale",     op == ImGuizmo::SCALE))     op = ImGuizmo::SCALE;


        if (ImGui::RadioButton("Local",  mode == ImGuizmo::LOCAL)) mode = ImGuizmo::LOCAL;

        ImGui::SameLine();

        if (ImGui::RadioButton("World",  mode == ImGuizmo::WORLD)) mode = ImGuizmo::WORLD;


        ImGui::Separator();

        ImGui::Checkbox("Snap", &snapEnabled);

        ImGui::InputFloat("Move snap",   &snapVal[0], 0.1f, 1.0f, "%.3f");

        ImGui::InputFloat("Rotate snap", &snapVal[1], 1.0f,  10.0f, "%.1f");

        ImGui::InputFloat("Scale snap",  &snapVal[2], 0.01f, 0.1f,  "%.3f");

        ImGui::End();


        // --- ImGuizmo setup ---

        ImGuizmo::BeginFrame();

        ImGuizmo::Enable(true);

        ImGuizmo::SetOrthographic(false);

        ImGuizmo::SetRect(0, 0, (float)GetScreenWidth(), (float)GetScreenHeight());


        // Build view/proj from current camera (before we possibly update it)

        float view[16], projection[16], model[16];

        Matrix viewMat = GetCameraMatrix(camera); // world->view

        // Use same params as raylib 3D for consistency

        Matrix projMat = MatrixPerspective(camera.fovy * DEG2RAD,

                                           GetScreenWidth()/(float)GetScreenHeight(),

                                           0.01f, 1000.0f);


        MatrixToFloat16(viewMat, view);

        MatrixToFloat16(projMat, projection);

        MatrixToFloat16(modelMat, model);


        // Manipulate (with optional snapping)

        if (snapEnabled) {

            float snap[3] = { snapVal[0], snapVal[1], snapVal[2] };

            ImGuizmo::Manipulate(view, projection, op, mode, model, nullptr, snap);

        } else {

            ImGuizmo::Manipulate(view, projection, op, mode, model);

        }


        // Block camera when gizmo is active/hovered or ImGui wants the mouse

        ImGuiIO& io = ImGui::GetIO();

        bool blockCam = io.WantCaptureMouse || ImGuizmo::IsOver() || ImGuizmo::IsUsing();


        // Update camera only when not interacting with UI/gizmo

        if (!blockCam) {

            UpdateCamera(&camera, CAMERA_ORBITAL);

        }


        // If user edited the gizmo, write back

        if (ImGuizmo::IsUsing()) {

            modelMat = Float16ToMatrix(model);

        }


        // --- 3D drawing using updated transforms ---

        // --- 3D drawing using updated transforms ---

        BeginMode3D(camera);

            DrawGrid(20, 1.0f);


            rlPushMatrix();

            rlMultMatrixf(MatrixToFloatPtr(modelMat)); // apply object transform

            

            // Draw the solid cube first

            DrawCube({0, 0.5f, 0}, 1, 1, 1, RED);

            

            // Disable depth test to draw the wireframe on top without Z-fighting

            rlDisableDepthTest();

            DrawCubeWires({0, 0.5f, 0}, 1, 1, 1, BLACK);

            rlEnableDepthTest(); // Re-enable for the rest of the scene


            rlPopMatrix();

        EndMode3D();


        // Render ImGui (gizmo is drawn here too, on top of 3D)

        rlImGuiEnd();


        EndDrawing();

    }


    rlImGuiShutdown();

    CloseWindow();

    return 0;

} 